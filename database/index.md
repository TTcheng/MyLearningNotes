# 索引

## 简介

[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)是对数据库表中一个或多个列（例如，employee 表的姓名 (name) 列）的值进行排序的结构。

例如这样一个查询：select * from table1 where id=10000。**如果没有索引，必须遍历整个表，直到ID等于10000的这一行被找到为止；**有了[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853)之后(必须是在ID这一列上建立的索引)，即可在索引中查找。由于**索引是经过某种算法优化过的，因而查找次数要少的多**。可见，索引是用来定位的。

从数据搜索实现的角度来看，索引也是另外一类文件/记录，它包含着可以指示出相关数据记录的各种记录。其中，每一索引都有一个相对应的搜索码，字符段的任意一个子集都能够形成一个搜索码。这样，索引就相当于所有数据目录项的一个集合，它能为既定的搜索码值的所有数据目录项提供定位所需的各种有效支持 [1]  。

## 基本概念

- 搜索码。它表示的是记录各种字符段的一个集合，它可以是一个或者是多个字符段的任意序列组合，并不是惟一的一个标识记录。
- 数据目录项。即为索引的相关元素，在建立索引的过程中，数据目录项一般具有各种不同的选择方式。
- 记录ID。每一个/段索引在存储内容中惟一的一个标识符。

## 主要种类

数据库索引好比是一本书前面的目录，能加快数据库的查询速度。



 [ ![SQL Server的B树结构](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=5b06cef88d1001e94a3c130d880f7b06/9d82d158ccbf6c8178c0abf9bc3eb13533fa4028.jpg) ](https://baike.baidu.com/pic/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/8751686/0/6648d73d880589e69e3d6249?fr=lemma&ct=single)  SQL Server的B树结构  

#### **聚簇索引**

聚簇索引按照数据存放的物理位置为顺序的，能提高多行检索的速度。

#### **非聚簇索引**

非聚簇索引不同于聚簇索引，它对于单行的检索很快。

### 根据数据库的功能划分

根据数据库的功能，可以在[数据库设计](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1)器中创建三种[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)：[唯一索引](https://baike.baidu.com/item/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95)、主键索引和[聚集索引](https://baike.baidu.com/item/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95)。有关数据库所支持的索引功能的详细信息，请参见数据库文档。

**提示**：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用[主键](https://baike.baidu.com/item/%E4%B8%BB%E9%94%AE)或[唯一约束](https://baike.baidu.com/item/%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F)。

#### **唯一索引**

唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。

#### **主键索引**

数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，**主键索引是唯一索引的特定类型**。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。

#### **聚集索引**

在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。

#### **索引列**

可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。

检查查询的WHERE和JOIN子句。在任一子句中包括的每一列都是索引可以选择的对象。对新索引进行试验以检查它对运行查询性能的影响。考虑已在表上创建的索引数量。最好避免在单个表上有很多索引。检查已在表上创建的索引的定义。最好避免包含共享列的重叠索引。

检查某列中唯一数据值的数量，并将该数量与表中的行数进行比较。比较的结果就是该列的可选择性，这有助于确定该列是否适合建立索引，如果适合，确定索引的类型。

## 基本特点

建立索引的目的是**加快**对表中记录的**查找**或**排序。**为表设置索引要付出**代价**的：一是**增加了数据库的存储空间**，二是在**插入和修改数据时要花费较多的时间**(因为索引也要随之变动)。数据库索引就是为了提高表的搜索效率而对某些字段中的值建立的目录 。

**创建**索引可以大大提高系统的性能。第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。第三，可以加速表和表之间的**连接**，特别是在实现数据的参考完整性方面特别有意义。第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

因为，增加索引也有许多不利的方面。第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

### 优点

通过建立索引可以极大地提高在数据库中获取所需信息的速度，同时还能提高服务器处理相关搜索请求的效率，从这个方面来看它具有以下优点 [1]  ：

- 在设计数据库时，通过创建一个惟一的索引，能够在索引和信息之间形成一对一的映射式的对应关系，增加数据的惟一性特点。
- 能提高数据的搜索及检索速度，符合数据库建立的初衷。
- 能够加快表与表之间的连接速度，这对于提高数据的参考完整性方面具有重要作用。
- 在信息检索过程中，若使用分组及排序子句进行时，通过建立索引能有效的减少检索过程中所需的分组及排序时间，提高检索效率。
- 建立索引之后，在信息查询过程中可以使用优化隐藏器，这对于提高整个信息检索系统的性能具有重要意义。

### 缺点

虽然索引的建立在提高检索效率方面具有诸多积极的作用，但还是存在下列缺点 [1]  ：

- 在数据库建立过程中，需花费较多的时间去建立并维护索引，特别是随着数据总量的增加，所花费的时间将不断递增。
- 在数据库中创建的索引需要占用一定的物理存储空间，这其中就包括数据表所占的数据空间以及所创建的每一个索引所占用的物理空间，如果有必要建立起聚簇索引，所占用的空间还将进一步的增加
- 在对表中的数据进行修改时，例如对其进行增加、删除或者是修改操作时，索引还需要进行动态的维护，这给数据库的维护速度带来了一定的麻烦。

## 注意事项

[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。

### 需要创建索引的表

一般来说，应该在这些列上创建索引：

- 在经常需要搜索的列上，可以加快搜索的速度；
- 在作为[主键](https://baike.baidu.com/item/%E4%B8%BB%E9%94%AE)的列上，强制该列的唯一性和组织表中数据的排列结构；
- 在经常用在连接的列上，这些列主要是一些[外键](https://baike.baidu.com/item/%E5%A4%96%E9%94%AE)，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
- 在经常使用在WHERE子句中的列上面创建[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)，加快条件的判断速度。

### 不应该创建索引的表

同样，对于有些列不应该创建索引。一般来说，不应该创建索引的这些列具有下列特点：

- 第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
- 第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，[结果集](https://baike.baidu.com/item/%E7%BB%93%E6%9E%9C%E9%9B%86)的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)，并不能明显加快检索速度。
- 第三，对于那些定义为text, image和[bit数据类型](https://baike.baidu.com/item/bit%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少,不利于使用索引。
- 第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改操作远远多于检索操作时，不应该创建索引。

## 操作案例

最普通的情况，是为出现在where子句的[字段](https://baike.baidu.com/item/%E5%AD%97%E6%AE%B5)建一个[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)。

如果在查询时常用类似以下的语句：

```sql
SELECT * FROM mytable WHERE category_id=1;
```

最直接的应对之道，是为category_id建立一个简单的[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)：

```sql
CREATE INDEX mytable_categoryid ON mytable (category_id);
```

OK.如果有不止一个选择条件呢？例如：

```sql
SELECT \* FROM mytable WHERE category_id=1 AND user_id=2;
```

第一反应可能是，再给user_id建立一个索引。不好，这不是一个最佳的方法。可以建立多重的[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)。

```sql
CREATE INDEX mytable_categoryid_userid ON mytable(category_id,user_id);
```
注意到在命名时的习惯了吗？使用"表名_[字段](https://baike.baidu.com/item/%E5%AD%97%E6%AE%B5)1名_字段2名"的方式。很快就会知道为什么这样做了。

现在已经为适当的字段建立了索引，不过，还是有点不放心吧，可能会问，数据库会真正用到这些索引吗？测试一下就OK，对于大多数的数据库来说，这是很容易的，只要使用EXPLAIN命令：

```sql
EXPLAIN
SELECT * FROM mytable
WHERE category_id=1 AND user_id=2;
This is what Postgres 7.1 returns (exactlyasI expected)
NOTICE:QUERY PLAN:
Index Scan using mytable_categoryid_userid on
mytable(cost=0.00..2.02 rows=1 width=16)
EXPLAIN
```

以上是postgres的数据，可以看到该数据库在查询的时候使用了一个[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)（一个好开始），而且它使用的是创建的第二个索引。看到上面命名的好处了吧，马上知道它使用适当的索引了。

接着，来个稍微复杂一点的，如果有个ORDERBY 子句呢？不管你信不信，大多数的数据库在使用orderby的时候，都将会从索引中受益。

````sql
SELECT * FROM mytable
WHERE category_id=1 AND user_id=2
ORDER BY adddate DESC;
````

很简单，就像为where子句中的[字段](https://baike.baidu.com/item/%E5%AD%97%E6%AE%B5)建立一个[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)一样，也为ORDER BY的子句中的字段建立一个索引：

```sql
CREATE INDEX mytable_categoryid_userid_adddate ON mytable (category_id,user_id,adddate);
```

注意:"mytable_categoryid_userid_adddate"将会被截短为"mytable_categoryid_userid_addda"

```
CREATE
EXPLAIN SELECT * FROM mytable
WHERE category_id=1 AND user_id=2
ORDER BY adddate DESC;
NOTICE:QUERY PLAN:
Sort(cost=2.03..2.03 rows=1 width=16)
->Index Scanusing mytable_categoryid_userid_addda
on mytable(cost=0.00..2.02 rows=1 width=16)
EXPLAIN
```

看看EXPLAIN的输出，数据库多做了一个没有要求的排序，这下知道性能如何受损了吧，看来对于数据库的自身运作是有点过于乐观了，那么，给数据库多一点提示吧。 

为了跳过排序这一步，并不需要其它另外的[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)，只要将查询语句稍微改一下。这里用的是postgres，将给该数据库一个额外的提示--在ORDER BY语句中，加入where语句中的[字段](https://baike.baidu.com/item/%E5%AD%97%E6%AE%B5)。这只是一个技术上的处理，并不是必须的，因为实际上在另外两个字段上，并不会有任何的排序操作，不过如果加入，postgres将会知道哪些是它应该做的。

```
EXPLAIN SELECT * FROM mytable
WHERE category_id=1 AND user_id=2
ORDER BY category_id DESC,user_id DESC,adddate DESC;
NOTICE:QUERY PLAN:
Index Scan Backward using
mytable_
```

现在使用料想的[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)了，而且它还挺聪明，知道可以从索引后面开始读，从而避免了任何的排序。

以上说得细了一点，不过如果数据库非常巨大，并且每日的页面请求达上百万算，想会获益良多的。不过，如果要做更为复杂的查询呢，例如将多张表结合起来查询，特别是where限制字句中的[字段](https://baike.baidu.com/item/%E5%AD%97%E6%AE%B5)是来自不止一个表格时，应该怎样处理呢？通常都尽量避免这种做法，因为这样数据库要将各个表中的东西都结合起来，然后再排除那些不合适的行，搞不好开销会很大。

如果不能避免，应该查看每张要结合起来的表，并且使用以上的策略来建立索引，然后再用EXPLAIN命令验证一下是否使用了料想中的索引。如果是的话，就OK。不是的话，可能要建立临时的表来将他们结合在一起，并且使用适当的索引。

要注意的是，建立太多的[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)将会影响更新和插入的速度，因为它需要同样更新每个[索引文件](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6)。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。

以上介绍的只是一些十分基本的东西，其实里面的学问也不少，单凭EXPLAIN是不能判定该方法是否就是最优化的，每个数据库都有自己的一些优化器，虽然可能还不太完善，但是它们都会在查询时对比过哪种方式较快，在某些情况下，建立[索引](https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95)的话也未必会快，例如索引放在一个不连续的存储空间时，这会增加读磁盘的负担，因此，哪个是最优，应该通过实际的使用环境来检验。

在刚开始的时候，如果表不大，没有必要作索引，意见是在需要的时候才作索引，也可用一些命令来优化表，例如MySQL可用"OPTIMIZETABLE"。